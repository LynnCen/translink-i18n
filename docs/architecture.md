# TransLink I18n 现代架构指南

> **写给所有人的架构文档** - 用最简单的方式理解国际化工具的设计

---

## 📖 目录

1. [什么是国际化？用生活例子理解](#什么是国际化用生活例子理解)
2. [我们的工具要解决什么问题？](#我们的工具要解决什么问题)
3. [整体架构：像搭积木一样](#整体架构像搭积木一样)
4. [三个核心积木块](#三个核心积木块)
5. [工作流程：从写代码到多语言](#工作流程从写代码到多语言)
6. [设计原则：为什么这样设计？](#设计原则为什么这样设计)
7. [当前状态和未来规划](#当前状态和未来规划)

---

## 什么是国际化？用生活例子理解

### 🏪 想象一家商店

假设你开了一家商店，店里有个牌子写着"欢迎光临"。

- **如果只服务中国人**：牌子写"欢迎光临"就够了
- **如果外国人也要来**：你需要准备多块牌子
  - 中文：欢迎光临
  - 英文：Welcome
  - 日文：いらっしゃいませ

**这就是国际化（i18n）**：让同一个应用能显示不同语言。

### 💻 在代码中的样子

```javascript
// 以前：硬编码中文
<button>登录</button>

// 现在：使用翻译函数
<button>{t('login')}</button>
// 中文环境显示：登录
// 英文环境显示：Login
```

---

## 我们的工具要解决什么问题？

### 🤔 开发者的痛点

想象你是一个开发者，要做一个多语言网站：

#### 问题1：怎么找到所有需要翻译的文字？

你的代码可能有几百个文件，每个文件都有中文：

- `Login.vue`: "登录"、"用户名"、"密码"
- `Dashboard.vue`: "欢迎回来"、"今日数据"
- `Settings.vue`: "设置"、"保存"、"取消"

**手动找？** 太累了，还容易漏！

**我们的解决方案**：自动扫描代码，找出所有中文文字，就像用放大镜找东西一样。

#### 问题2：翻译后的文字怎么管理？

翻译完成后，你需要：

- 保存中文版本
- 保存英文版本
- 保存日文版本
- 还要知道哪个翻译对应哪个位置

**用Excel？** 运营人员喜欢，但开发者不方便。
**用JSON？** 开发者方便，但运营人员不会用。

**我们的解决方案**：

- 给开发者：生成JSON文件（像字典一样）
- 给运营人员：生成Excel表格（像表格一样）
- 两者可以互相转换

#### 问题3：代码里怎么写翻译？

```javascript
// 方式1：直接写中文（不好，无法切换语言）
<button>登录</button>

// 方式2：用函数（好，但写起来麻烦）
<button>{t('a1b2c3d4')}</button>  // 这个a1b2c3d4是什么鬼？

// 方式3：用我们的工具（最好）
<button>$tsl('登录')</button>  // 写中文，自动转换
```

**我们的解决方案**：写代码时直接用中文，工具自动帮你转换成翻译函数。

---

## 整体架构：像搭积木一样

### 🏗️ 把复杂问题拆成简单模块

想象你要建一栋房子，需要：

1. **工具包（CLI）**：像工具箱，用来"找文字"、"生成翻译文件"
2. **运行引擎（Runtime）**：像房子的水电系统，让翻译在运行时工作
3. **构建插件（Vite Plugin）**：像装修工具，在打包时优化代码

```
┌─────────────────────────────────────────┐
│         你的应用（网站/App）              │
│                                         │
│  ┌──────────┐  ┌──────────┐            │
│  │ Vue组件  │  │ React组件│            │
│  └──────────┘  └──────────┘            │
└─────────────────────────────────────────┘
           │                    │
           │ 使用                │ 使用
           ▼                    ▼
┌─────────────────────────────────────────┐
│      Runtime（运行时引擎）               │
│  - 翻译函数 t()                         │
│  - 语言切换                             │
│  - 缓存管理                             │
└─────────────────────────────────────────┘
           │
           │ 读取翻译文件
           ▼
┌─────────────────────────────────────────┐
│  翻译文件（locales/）                    │
│  - zh-CN.json（中文）                    │
│  - en-US.json（英文）                    │
│  - ja-JP.json（日文）                    │
└─────────────────────────────────────────┘
           ▲
           │ 生成
           │
┌─────────────────────────────────────────┐
│      CLI（命令行工具）                   │
│  - extract：从代码中提取文字             │
│  - build：构建翻译文件                   │
│  - export：导出Excel给运营              │
└─────────────────────────────────────────┘
```

### 📦 三个独立的包

就像三个独立的工具箱，每个都能单独使用：

```
┌─────────────┐
│  CLI工具包  │  ← 可以单独用，用来提取和生成翻译
└─────────────┘

┌─────────────┐
│ Runtime引擎 │  ← 可以单独用，在你的应用里运行翻译
└─────────────┘

┌─────────────┐
│ Vite插件    │  ← 可以单独用，在构建时优化代码
└─────────────┘
```

**为什么分开？**

- 就像你不需要买整个工具箱，只需要一把螺丝刀
- 如果你只用Runtime，就不需要安装CLI
- 体积更小，速度更快

---

## 三个核心积木块

### 1️⃣ CLI工具包：像"文字收集器"

**作用**：从代码里找出所有中文，生成翻译文件

**就像**：一个智能的"找字机器人"

```
你的代码文件
    │
    │ 扫描
    ▼
CLI工具
    │
    │ 提取中文
    ▼
找到的文字：
  - "登录" (在 Login.vue 第12行)
  - "用户名" (在 Login.vue 第15行)
  - "欢迎回来" (在 Dashboard.vue 第5行)
    │
    │ 生成
    ▼
翻译文件：
  - zh-CN.json（中文版本）
  - en-US.json（英文版本，待翻译）
```

**主要功能**：

| 命令      | 作用             | 生活比喻                   |
| --------- | ---------------- | -------------------------- |
| `extract` | 从代码中提取文字 | 像用吸尘器收集散落的文字   |
| `build`   | 构建翻译文件     | 像把收集的文字整理成字典   |
| `export`  | 导出Excel        | 像把字典做成表格给运营看   |
| `import`  | 从Excel导入      | 像把运营填好的表格转回字典 |

### 2️⃣ Runtime引擎：像"翻译大脑"

**作用**：在应用运行时，根据用户选择的语言显示对应翻译

**就像**：一个会多国语言的翻译员

```
用户选择语言：英文
    │
    │
Runtime引擎
    │
    │ 查找翻译
    ▼
翻译文件 (en-US.json)
    │
    │ 返回
    ▼
显示：Login（而不是"登录"）
```

**主要功能**：

- **翻译函数** `t('key')`：根据key返回对应语言的文字
- **语言切换**：用户点击切换语言，整个应用立即更新
- **缓存**：已经翻译过的文字存起来，下次直接用（更快）
- **框架支持**：Vue和React都能用

### 3️⃣ Vite插件：像"代码优化器"

**作用**：在构建时，把代码中的中文自动转换成翻译函数

**就像**：一个自动翻译助手，在你写代码时帮你转换

```
你写的代码：
<button>$tsl('登录')</button>
    │
    │ 构建时处理
    ▼
Vite插件转换
    │
    │
    ▼
转换后的代码：
<button>{t('a1b2c3d4')}</button>
```

**主要功能**：

- **代码转换**：`$tsl('登录')` → `t('a1b2c3d4')`
- **热更新**：修改翻译文件，页面自动刷新（不用重启）
- **懒加载**：只加载当前语言的文件（更快）
- **构建优化**：打包时移除未使用的翻译

---

## 工作流程：从写代码到多语言

### 📝 完整流程（像做菜一样）

#### 第1步：写代码（准备食材）

```vue
<!-- Login.vue -->
<template>
  <button>$tsl('登录')</button>
  <input placeholder="$tsl('用户名')" />
</template>
```

**就像**：准备做菜的食材（代码里的中文）

#### 第2步：提取文字（收集食材）

```bash
translink extract
```

**做了什么**：

- 扫描所有代码文件
- 找出所有 `$tsl('...')` 里的中文
- 生成一个"待翻译清单"

**生成的文件**：

```json
// locales/zh-CN.json（中文版本，作为参考）
{
  "a1b2c3d4": "登录",
  "e5f6g7h8": "用户名"
}

// locales/en-US.json（英文版本，待翻译）
{
  "a1b2c3d4": "",  // 空着，等翻译
  "e5f6g7h8": ""
}
```

#### 第3步：导出Excel（给运营人员）

```bash
translink export --format excel
```

**生成Excel表格**：

| Key      | zh-CN  | en-US | ja-JP | Context | File      | Line |
| -------- | ------ | ----- | ----- | ------- | --------- | ---- |
| a1b2c3d4 | 登录   | (空)  | (空)  | button  | Login.vue | 12   |
| e5f6g7h8 | 用户名 | (空)  | (空)  | input   | Login.vue | 15   |

**运营人员**：在Excel里填上英文和日文翻译

#### 第4步：导入翻译（把Excel转回JSON）

```bash
translink import --input translations.xlsx
```

**更新后的文件**：

```json
// locales/en-US.json（现在有翻译了）
{
  "a1b2c3d4": "Login",
  "e5f6g7h8": "Username"
}
```

#### 第5步：构建（打包）

```bash
translink build
```

**优化和压缩翻译文件，准备发布**

#### 第6步：在应用中使用

```vue
<script setup>
import { useI18n } from '@translink/i18n-runtime/vue';

const { t } = useI18n();
</script>

<template>
  <button>{{ t('a1b2c3d4') }}</button>
  <!-- 中文环境显示：登录 -->
  <!-- 英文环境显示：Login -->
</template>
```

---

## 设计原则：为什么这样设计？

### 🎯 原则1：完全独立（像乐高积木）

**设计**：每个包都可以单独安装和使用

**为什么**：

- 如果你只需要Runtime，就不装CLI（省空间）
- 如果你只需要CLI，就不装Runtime（省空间）
- 就像买乐高，你只需要红色积木，就不买整盒

**当前问题**：

- Vite插件依赖CLI（不合理，应该独立）
- CLI依赖Vika（不合理，应该可选）

**未来改进**：

- 每个包完全独立
- 可选功能做成插件

### 🎯 原则2：按需使用（像自助餐）

**设计**：需要什么装什么，不需要的不装

**为什么**：

- 体积更小（只装需要的）
- 速度更快（没有多余代码）
- 更灵活（可以自由组合）

**例子**：

```bash
# 只装Runtime（最小，~50KB）
npm install @translink/i18n-runtime

# 只装CLI（中等，~1.5MB）
npm install @translink/i18n-cli

# 装Vite插件（需要Runtime，~600KB）
npm install @translink/vite-plugin-i18n @translink/i18n-runtime
```

### 🎯 原则3：解耦云端（像本地和云端）

**设计**：不强制使用云端服务（Vika），支持本地文件（Excel/JSON）

**为什么**：

- 有些团队不需要云端协作
- 有些团队喜欢用Excel管理
- 云端服务可能有API限制

**当前问题**：

- CLI强依赖Vika（不合理）
- 没有Excel导出功能

**未来改进**：

- Vika变成可选插件
- 内置Excel导出/导入
- 支持多种工作流

### 🎯 原则4：实用优先（像瑞士军刀）

**设计**：解决实际问题，简单易用

**为什么**：

- 开发者要的是能用的工具，不是复杂的概念
- 运营人员要的是能填的表格，不是技术文档
- 简单比完美更重要

**例子**：

- Excel导出：运营人员直接填，不用学技术
- JSON文件：开发者直接读，不用转换
- 自动转换：写代码时用中文，工具自动处理

---

## 当前状态和未来规划

### 📊 当前状态（像在建的房子）

根据审查报告，当前项目：

#### ✅ 已经完成的部分（65%）

- **基础架构**：三个包的结构已经搭建好
- **核心功能**：提取文字、翻译引擎基本可用
- **文档**：文档很完善（85%）

#### ⚠️ 需要修复的问题（35%）

**严重问题**（必须立即修复）：

1. **TypeScript配置冲突**
   - **问题**：开发时配置和构建时配置混在一起
   - **影响**：无法正确生成类型文件
   - **比喻**：就像有两套说明书，不知道按哪个来

2. **构建工具不统一**
   - **问题**：CLI用tsup，Runtime用rollup
   - **影响**：维护困难，输出不一致
   - **比喻**：就像用不同的工具做同一件事，结果不一样

3. **包之间依赖混乱**
   - **问题**：Vite插件依赖CLI（不应该）
   - **影响**：无法独立使用
   - **比喻**：就像买一个工具，必须买另一个工具才能用

**重要问题**（需要尽快完成）：

4. **核心功能未完成**
   - `init`命令：0%（未实现）
   - `push/pull`命令：10%（只有框架）
   - Excel导出：0%（未实现）

5. **Vika集成未完成**
   - 云端功能完全不可用
   - 需要改成可选插件

### 🗺️ 未来规划（像施工计划）

#### 阶段零：修复基础问题（Week 1-2）🔴 必须完成

**目标**：让项目能正常构建和开发

**任务**：

1. 修复TypeScript配置（分离开发/构建配置）
2. 统一构建工具（都用tsup）
3. 修复包依赖关系（让每个包独立）
4. 优化文件组织（测试文件移出src）
5. 优化Turbo配置（测试不依赖构建）

**验收标准**：

- ✅ 所有包能正确构建
- ✅ 类型检查正常
- ✅ 测试能独立运行

#### 阶段一：架构解耦（Week 3-4）🟡 重要

**目标**：让每个包完全独立

**任务**：

1. 移除CLI对Vika的强依赖
2. 移除Vite插件对CLI的依赖
3. 确保Runtime完全独立

**验收标准**：

- ✅ 每个包可以单独安装使用
- ✅ 不安装其他包也能工作

#### 阶段二：功能实现（Week 5-6）🟡 重要

**目标**：实现Excel工作流

**任务**：

1. 实现Excel导出功能
2. 实现Excel导入功能
3. 完善`init`命令
4. 完善`extract`和`build`命令

**验收标准**：

- ✅ 可以导出Excel给运营
- ✅ 可以从Excel导入翻译
- ✅ 完整工作流可用

#### 阶段三：插件系统（Week 7-8）🟢 次要

**目标**：让Vika变成可选插件

**任务**：

1. 设计插件接口
2. 实现插件加载机制
3. 开发Vika插件（独立包）

**验收标准**：

- ✅ Vika插件可以独立安装
- ✅ 不装Vika也能用CLI

#### 阶段四：测试和优化（Week 9-10）🟢 次要

**目标**：完善测试和文档

**任务**：

1. 添加单元测试
2. 添加集成测试
3. 性能优化
4. 文档更新

**验收标准**：

- ✅ 测试覆盖率>80%
- ✅ 文档完整更新

---

## 🎓 总结：用一句话理解

### 整体架构

> **CLI是"文字收集器"，Runtime是"翻译大脑"，Vite插件是"代码优化器"**

### 工作流程

> **写代码 → 提取文字 → 导出Excel → 运营翻译 → 导入翻译 → 构建 → 使用**

### 设计原则

> **每个工具独立，按需使用，不强制云端，简单实用**

### 当前状态

> **基础已搭建（65%），需要修复配置问题，然后实现Excel功能**

---

## 📚 延伸阅读

如果你想深入了解技术细节，可以查看：

- [重构计划](./REFACTOR_PLAN.md) - 详细的技术重构方案
- [审查报告](./PROJECT_AUDIT_REPORT.md) - 发现的问题和解决方案
- [API文档](./apps/docs/api/) - 每个包的详细API

---

**文档完成时间**：2026-01-03  
**目标读者**：所有人（包括90岁奶奶）  
**更新频率**：随项目进展更新
